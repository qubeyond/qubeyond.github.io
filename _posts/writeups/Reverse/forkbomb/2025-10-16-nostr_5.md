---
title: "Nostr 4"
date: 2025-10-16
tags: [reverse, writeup]  
categories: [Reverse]
tagline: ""
header:
  overlay_image: /assets/images/IMG_writeups/IMG_Reverse/IMG_forkbomb/forkbomb_logo.jpg
  overlay_filter: 0.5 
  overlay_color: "#fff"
  actions:
    - label: "Lab forkbomb"
      url: "https://rev-kids20.forkbomb.ru/tasks/RE2_nostr200"
classes: wide
---

{% raw %}

Нужно подобрать серийный номер.

- [ELF](https://rev-kids20.forkbomb.ru/files/rev/re2/s5.out)
- [PE](https://rev-kids20.forkbomb.ru/files/rev/re2/s5.exe)

# Solution

Не буду себе изменять - пойду смотреть статику.

```c
int32_t main(int32_t argc, char** argv, char** envp)
    void* const __return_addr_1 = __return_addr
    int32_t* var_c = &argc
    printf(format: "Enter serial number: ")
    scanf(format: "%s", 0x804a02c)
    
    if (Check() == 0)
        PrintError()
    else
        PrintOK()
    
    return 0
```

Ничего интересного тут нет. Нужно смотреть функцию `Check`:

```c
int32_t Check()
    int32_t eax_1 = strlen(&buf) - 1
    
    if (eax_1 != 6)
        return 0
    
    if (buf.b != 0x61)
        return 0
    
    void* var_10_1 = 1
    
    while (true)
        if (var_10_1 s>= eax_1)
            return 1
        
        if (sx.d(*(var_10_1 + 0x804a02c)) != var_10_1 + sx.d(*(var_10_1 + 0x804a02b)))
            break
        
        var_10_1 += 1
    return 0
```

Вот тут уже интереснее.

```c
    int32_t eax_1 = strlen(&buf) - 1
    
    if (eax_1 != 6)
        return 0
```

Длина серийного номера должна быть равнa `6`.

```c
    if (buf.b != 'a')
        return 0
```

Первый символ - это `a`.

А вот тут чутка сложнее:

```c
while (true)
        if (var_10_1 s>= eax_1)
            return 1
        
        if (sx.d(*(var_10_1 + 0x804a02c)) != var_10_1 + sx.d(*(var_10_1 + 0x804a02b)))
            break
        
        var_10_1 += 1
```

Циклы `for` - это лишь синтаксический сахар над `while`:

```c
for (int i = 0; i < 10; i++) { ... }

int i = 0;
while (i++ < 10) { ... }
```

Поэтому у нас происходит проверка длины. Далее идет сравнение.

У любой переменной есть адрес в памяти. В языке `C` массив занимает определенное место в памяти. Элементы в нем располагаются друг за другом. Для доступа к элементу по номеру ячейки мы можем пользоваться следующей логикой:

```c
char buf[10];

*(&buf + 1); // buf[1];
```

Вместо `&buf` мы можем подставить адрес. И, что интересно, порядок нам не важен, поэтому мы можем использовать и следующую запись:

```c
*(1 + &buf); // buf[1];
```

Вернемся к нашей таске:

```c
(sx.d(*(var_10_1 + 0x804a02c)) != var_10_1 + sx.d(*(var_10_1 + 0x804a02b)))
```

Обратим внимание, что разность адресов равна `1`: `0x804a02c - 0x804a02b`. Что лежит у нас по этим адресам?

![IMG](/assets/images/IMG_writeups/IMG_Reverse/IMG_forkbomb/IMG_nostr_5/1.png){: height="200" .align-center}

А вот и наш `buf`. Преобразуем наш код с учетом того, что мы разобрали:

```c
buf[val_10_1] != var_10_1 + buf[val_10_1 - 1]
```

Все стало ясно. Напишу код на `Python` для генерации серийного номера:

```python
if __name__ == '__main__':
    ans = ['a']

    for i in range(1, 7):
        ans.append(chr(ord(ans[i - 1]) + i))

    print(''.join(ans))
```

Запущу его:

```bash
cu63:Nostr 5/ $ python solver.py                                                                           
abdgkpv
```

Попробую сдать флаг:

![IMG](/assets/images/IMG_writeups/IMG_Reverse/IMG_forkbomb/IMG_nostr_5/2.png){: height="200" .align-center}

{% endraw %}