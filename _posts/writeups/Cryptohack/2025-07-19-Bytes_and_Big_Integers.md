---
title: "CryptoHack Lab. Bytes and Big Integers"
date: 2025-07-19
tags: [crypto, writeup]  
categories: [Crypto]
tagline: ""
header:
  overlay_image: /assets/images/IMG_writeups/IMG_Cryptohack/cryptohack_logo.webp
  overlay_filter: 0.5 
  overlay_color: "#fff"
  actions:
    - label: "СryptoHack Lab"
      url: "https://cryptohack.org/courses/intro/enc4/"
---

Буквы флага переведены в их десятичное представление. Для решения нужно получить ключ.

```
11515195063862318899931685488813747395775516287289682636499965282714637259206269
```

## Solution

Давайте разберем задание подробнее.

```
message: HELLO
ascii bytes: [72, 69, 76, 76, 79]
hex bytes: [0x48, 0x45, 0x4c, 0x4c, 0x4f]
base-16: 0x48454c4c4f
base-10: 310400273487
```

Такс. Значит, взяли флаг, разбили его на символы, для каждого символа взяли его `ascii`-код, перевели его в `HEX`. Полученные `HEX`-значения поставили рядом и перевели их в десетичную систему исчисления. Пон...

Разберем как из десятичной системы перевести в шестнадцатиричную:

1. Делим число на 16;
2. Берем остаток от деления — он станет `hex`-значением;
3. Делим результат на 16, пока не дойдем до 0;
4. Записываем остатки в обратном порядке. Это и будет нужное число.

> В `HEX` могут быть следующие значения: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A(10), B(11), C(12), D(13), E(14), F(15).

Пример:

| Делим             | Частное     | Остаток | Остаток (hex) |
| ----------------- | ----------- | ------- | ------------- |
| 310400273487 ÷ 16 | 19375017092 | 15      | `F`           |
| 19375017092 ÷ 16  | 1210938568  | 4       | `4`           |
| 1210938568 ÷ 16   | 75683660    | 8       | `8`           |
| 75683660 ÷ 16     | 4730228     | 12      | `C`           |
| 4730228 ÷ 16      | 295639      | 4       | `4`           |
| 295639 ÷ 16       | 18477       | 7       | `7`           |
| 18477 ÷ 16        | 1154        | 13      | `D`           |
| 1154 ÷ 16         | 72          | 2       | `2`           |
| 72 ÷ 16           | 4           | 8       | `8`           |
| 4 ÷ 16            | 0           | 4       | `4`           |

А вот и полученное число:

```
0x482D74C84F
```

Напишу данный алгоритм на `Python`:

```python
key = 11515195063862318899931685488813747395775516287289682636499965282714637259206269
flag = []
while key > 0:
	n = key % 256
	flag.append(chr(n))
	key //= 256

flag = flag[::-1]
print(''.join(flag))
```

А вот и ответ:

```
crypto{3nc0d1n6_4ll_7h3_w4y_d0wn}
```

В `Python` процесс можно сделать сильно проще. Так как в нем есть поддержка больших чисел, то мы просто можем вызвать стандартную функцию `hex()`, а дальше процесс вам известен:

```python
key = 11515195063862318899931685488813747395775516287289682636499965282714637259206269
key = hex(key)[2:]
flag = []
for i in range(0, len(key), 2):
    flag.append(chr(int(key[i:i+2], 16)))

print(''.join(flag))
```