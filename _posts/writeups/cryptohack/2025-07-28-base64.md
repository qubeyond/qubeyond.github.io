---
title: "CryptoHack Lab. base64"
date: 2025-07-28
tags: [crypto, writeup]  
categories: [Crypto]
tagline: ""
header:
  overlay_image: /assets/images/IMG_writeups/IMG_cryptohack/cryptohack_logo.webp
  overlay_filter: 0.5 
  overlay_color: "#fff"
  actions:
    - label: "СryptoHack Lab"
      url: "https://cryptohack.org/courses/intro/enc3/"
layout: single
toc: true
toc_sticky: true
toc_label: "Оглавление"
---

Для решения нужно достать ключи из `hex`-строки. Для этого нужно декодировать ее в байты, а затем закодировать в `base64`.

```
72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf
```

## Solution

Для начала разберем, что от нас требуется.   

`base64` — это способ кодирования информации, в котором для кодирования используется `64` бита. Данные разбиваются на блоки по `3` октета. Далее кодируемая последовательность разбивается по `6` бит и сопоставляет символ из таблицы с заданным значением. Если доступного символа нет, то вместо него подставлеется `=`.  

Мне нравится следующая цитата:

<blockquote>
Чего не могу создать, того не понимаю.<br>
<small>— Ричард Фейнман (но это не точно)</small>
</blockquote>

Поэтому помучаемся и напишем свою реализацию один раз.

## Пишем свой `base64`

> Не стоит серьезно воспринимать этот код, а тем более использовать его где-то в проде. Этот код написан для того, чтобы новички могли лучше понять принцип работы `base64`.

### Кодирование

Алгоритм кодирование у нас следующий:

1. Переводим строку в двоичный вид;
2. Разбиваем входную строку на последовательности из `24` бит. Если не хватает символов, то добавляем `8`/`16` нулей, а в закодированный текст добавляется `1`/`2` символа `=` соответственно;
3. Разбиваем на группы по `6` бит;
4. Кодируем по таблице и добавляем `=`, если дополняли нулями;

<details>
<summary>Таблица кодирования `base64`</summary>  
<br>
<table>
  <thead>
    <tr>
      <th>Decimal</th>
      <th>Binary</th>
      <th>Base64 Symbol</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>0</td><td>000000</td><td>A</td></tr>
    <tr><td>1</td><td>000001</td><td>B</td></tr>
    <tr><td>2</td><td>000010</td><td>C</td></tr>
    <tr><td>3</td><td>000011</td><td>D</td></tr>
    <tr><td>4</td><td>000100</td><td>E</td></tr>
    <tr><td>5</td><td>000101</td><td>F</td></tr>
    <tr><td>6</td><td>000110</td><td>G</td></tr>
    <tr><td>7</td><td>000111</td><td>H</td></tr>
    <tr><td>8</td><td>001000</td><td>I</td></tr>
    <tr><td>9</td><td>001001</td><td>J</td></tr>
    <tr><td>10</td><td>001010</td><td>K</td></tr>
    <tr><td>11</td><td>001011</td><td>L</td></tr>
    <tr><td>12</td><td>001100</td><td>M</td></tr>
    <tr><td>13</td><td>001101</td><td>N</td></tr>
    <tr><td>14</td><td>001110</td><td>O</td></tr>
    <tr><td>15</td><td>001111</td><td>P</td></tr>
    <tr><td>16</td><td>010000</td><td>Q</td></tr>
    <tr><td>17</td><td>010001</td><td>R</td></tr>
    <tr><td>18</td><td>010010</td><td>S</td></tr>
    <tr><td>19</td><td>010011</td><td>T</td></tr>
    <tr><td>20</td><td>010100</td><td>U</td></tr>
    <tr><td>21</td><td>010101</td><td>V</td></tr>
    <tr><td>22</td><td>010110</td><td>W</td></tr>
    <tr><td>23</td><td>010111</td><td>X</td></tr>
    <tr><td>24</td><td>011000</td><td>Y</td></tr>
    <tr><td>25</td><td>011001</td><td>Z</td></tr>
    <tr><td>26</td><td>011010</td><td>a</td></tr>
    <tr><td>27</td><td>011011</td><td>b</td></tr>
    <tr><td>28</td><td>011100</td><td>c</td></tr>
    <tr><td>29</td><td>011101</td><td>d</td></tr>
    <tr><td>30</td><td>011110</td><td>e</td></tr>
    <tr><td>31</td><td>011111</td><td>f</td></tr>
    <tr><td>32</td><td>100000</td><td>g</td></tr>
    <tr><td>33</td><td>100001</td><td>h</td></tr>
    <tr><td>34</td><td>100010</td><td>i</td></tr>
    <tr><td>35</td><td>100011</td><td>j</td></tr>
    <tr><td>36</td><td>100100</td><td>k</td></tr>
    <tr><td>37</td><td>100101</td><td>l</td></tr>
    <tr><td>38</td><td>100110</td><td>m</td></tr>
    <tr><td>39</td><td>100111</td><td>n</td></tr>
    <tr><td>40</td><td>101000</td><td>o</td></tr>
    <tr><td>41</td><td>101001</td><td>p</td></tr>
    <tr><td>42</td><td>101010</td><td>q</td></tr>
    <tr><td>43</td><td>101011</td><td>r</td></tr>
    <tr><td>44</td><td>101100</td><td>s</td></tr>
    <tr><td>45</td><td>101101</td><td>t</td></tr>
    <tr><td>46</td><td>101110</td><td>u</td></tr>
    <tr><td>47</td><td>101111</td><td>v</td></tr>
    <tr><td>48</td><td>110000</td><td>w</td></tr>
    <tr><td>49</td><td>110001</td><td>x</td></tr>
    <tr><td>50</td><td>110010</td><td>y</td></tr>
    <tr><td>51</td><td>110011</td><td>z</td></tr>
    <tr><td>52</td><td>110100</td><td>0</td></tr>
    <tr><td>53</td><td>110101</td><td>1</td></tr>
    <tr><td>54</td><td>110110</td><td>2</td></tr>
    <tr><td>55</td><td>110111</td><td>3</td></tr>
    <tr><td>56</td><td>111000</td><td>4</td></tr>
    <tr><td>57</td><td>111001</td><td>5</td></tr>
    <tr><td>58</td><td>111010</td><td>6</td></tr>
    <tr><td>59</td><td>111011</td><td>7</td></tr>
    <tr><td>60</td><td>111100</td><td>8</td></tr>
    <tr><td>61</td><td>111101</td><td>9</td></tr>
    <tr><td>62</td><td>111110</td><td>+</td></tr>
    <tr><td>63</td><td>111111</td><td>/</td></tr>
  </tbody>
</table>

</details>

### Пример

![IMG](/assets/images/IMG_writeups/IMG_cryptohack/IMG_base64/1.png){: height="200" .align-center}

Проверим:

```bash
cu63:base64/ $ echo 'QUJDRUQ=' | base64 -d
ABCED
```

Реализация на `Python`:

```python
def base64_encode(s: bytes) -> str:
    encoded_s = []
    adjust = (3 - (len(s) % 3)) % 3

    for i in range(0, len(s), 3):
        octets = s[i:i+3]
        octets = ''.join([f'{octet:08b}' for octet in octets])

        octets = octets.ljust(24, '0')
        print(octets, len(octets))
        for j in range(0, 24, 6):
            c = octets[j:j+6]
            pos = int(c, 2)
            encoded_s.append(encode_table[pos])

    if adjust != 0:
        encoded_s[-adjust::] = '=' * adjust

    return ''.join(encoded_s)
```

Протестирую его с `ABCDE`:

```bash
cu63:base64/$ python decrypt.py
QUJDREU=
```

Отлично. Перейдем к декодированию)

## Декодирование

Логично предположить, что у нас теперь происходит обратный процесс:

1. Разбиваем строку `base64` на символы;
2. Заменяем каждый символ `6` битами из таблицы кодирования. Считаем знаки `=` и исключаем их из декодированного текста;
3. Полученные биты объединяем по `8`, чтобы получить `ascii` символы;
4. Отображаем полученные символы;

![IMG](/assets/images/IMG_writeups/IMG_cryptohack/IMG_base64/2.png){: height="200" .align-center}

Реализация на `Python`:

```python
def base64_decode(s: str) -> bytes:
    adjust = s.count('=')
    bin_repr = []
    decoded_str = []

    for c in s:
        if c == '=':
            bin_repr.append('0'*6)
            continue
        pos = encode_table.index(c)
        bin_repr.append(f'{pos:06b}')
    bin_repr = ''.join(bin_repr)

    if adjust != 0:
        bin_repr = bin_repr[:-adjust * 8]

    for i in range(0, len(bin_repr), 8):
        c = bin_repr[i:i+8]
        decoded_str.append(chr(int(c, 2)))

    return ''.join(decoded_str).encode('utf-8')
```

### Итоговый код

```python
encode_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'


def base64_decode(s: str) -> bytes:
    adjust = s.count('=')
    bin_repr = []
    decoded_str = []

    for c in s:
        if c == '=':
            bin_repr.append('0'*6)
            continue
        pos = encode_table.index(c)
        bin_repr.append(f'{pos:06b}')
    bin_repr = ''.join(bin_repr)

    if adjust != 0:
        bin_repr = bin_repr[:-adjust * 8]

    for i in range(0, len(bin_repr), 8):
        c = bin_repr[i:i+8]
        decoded_str.append(chr(int(c, 2)))

    return ''.join(decoded_str).encode('utf-8')


def base64_encode(s: bytes) -> str:
    encoded_s = []Ы
    adjust = (3 - (len(s) % 3)) % 3

    for i in range(0, len(s), 3):
        octets = s[i:i+3]
        octets = ''.join([f'{octet:08b}' for octet in octets])

        octets = octets.ljust(24, '0')
        print(octets, len(octets))
        for j in range(0, 24, 6):
            c = octets[j:j+6]
            pos = int(c, 2)
            encoded_s.append(encode_table[pos])

    if adjust != 0:
        encoded_s[-adjust::] = '=' * adjust

    return ''.join(encoded_s)


if __name__ == '__main__':
    input_s = 'ABCDE'
    input_s = input_s.encode('utf-8')
    crypted_str = base64_encode(input_s)
    print(crypted_str)
    decrypted_str = base64_decode(crypted_str)
    print(decrypted_str)
```

## Наконец решим таску

Поигрались и хватит. С алгоритмом мы разобрались (разобрались же?). Можно использовать эту реализацию, либо использовать готовые либы и тулы. Теперь уже точно можно)

Я воспользуюсь двумя способами.  

1) Готовая либа:

```python
import base64


if __name__ == '__main__':
    hex_s = '72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf'
    flag = bytes.fromhex(hex_s)
    print(base64.b64encode(flag).decode())
```

2) [Моя реализация](#итоговый-код) (ну вы ее уже видели)

Флаг:

```
crypto/Base+64+Encoding+is+Web+Safe/
```
